from __future__ import annotations

import ast
import argparse
import os
from pathlib import Path
from typing import Iterable
from dotenv import load_dotenv

load_dotenv()


def is_command_base(base: ast.expr) -> bool:
    # Command
    if isinstance(base, ast.Name) and base.id == "Command":
        return True

    # Command[...]
    if isinstance(base, ast.Subscript):
        v = base.value
        if isinstance(v, ast.Name) and v.id == "Command":
            return True
        if isinstance(v, ast.Attribute) and v.attr == "Command":
            return True

    # pkg.Command
    if isinstance(base, ast.Attribute) and base.attr == "Command":
        return True

    return False


def extract_command_classes(py_file: Path) -> list[str]:
    src = py_file.read_text(encoding="utf-8")
    tree = ast.parse(src, filename=str(py_file))
    out: list[str] = []

    for node in tree.body:
        if isinstance(node, ast.ClassDef):
            if any(is_command_base(b) for b in node.bases):
                out.append(node.name)

    return out


def iter_python_files(pkg_dir: Path) -> Iterable[Path]:
    for py in sorted(pkg_dir.rglob("*.py")):
        if py.name == "__init__.py":
            continue
        if py.name.startswith("_"):
            continue
        yield py


def collect_items(pkg_dir: Path) -> list[tuple[str, list[str]]]:
    """
    pkg_dir: .../web/commands OR .../web/flows
    """
    if not pkg_dir.exists():
        return []

    items: list[tuple[str, list[str]]] = []
    for py in iter_python_files(pkg_dir):
        classes = extract_command_classes(py)
        if not classes:
            continue

        rel = py.relative_to(pkg_dir).with_suffix("")  # e.g. subpkg/foo
        module = ".".join(rel.parts)  # e.g. "subpkg.foo"
        items.append((module, sorted(set(classes))))

    items.sort(key=lambda x: x[0])
    return items


def gen_init_content(package_name: str, items: list[tuple[str, list[str]]]) -> str:
    lines: list[str] = []
    lines.append('"""')
    lines.append("AUTOGENERATED FILE. DO NOT EDIT MANUALLY.")
    lines.append("Run: python tools/gen_instagram_web_exports.py")
    lines.append("")
    lines.append(f"Public exports for insta_wizard.web.{package_name}.")
    lines.append('"""')
    lines.append("")

    for module, classes in items:
        lines.append(f"from .{module} import {', '.join(classes)}")

    lines.append("")
    lines.append("__all__ = [")
    for _, classes in items:
        for cls in classes:
            lines.append(f'    "{cls}",')
    lines.append("]")
    lines.append("")

    return "\n".join(lines)


def write_exports(root_dir: Path, subpkg: str) -> None:
    pkg_dir = root_dir / subpkg
    if not pkg_dir.exists():
        print(f"Skip (not found): {pkg_dir}")
        return

    items = collect_items(pkg_dir)
    content = gen_init_content(subpkg, items)

    out_file = pkg_dir / "__init__.py"
    out_file.write_text(content, encoding="utf-8")
    print(f"Written: {out_file} ({len(items)} modules)")


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--root",
        type=str,
        default=os.getenv("WEB_PACKAGE_PATH"),
        help="Path to insta_wizard/web package directory",
    )
    args = parser.parse_args()

    root_dir = Path(args.root).resolve()
    if not root_dir.exists():
        raise SystemExit(f"Root dir not found: {root_dir}")

    for subpkg in ("commands", "flows"):
        write_exports(root_dir, subpkg)


if __name__ == "__main__":
    main()
